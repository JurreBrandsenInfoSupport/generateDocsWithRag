
===== New File Processed =====

--- Chunk 1 ---

using System.Collections.Generic;
using System.Collections.ObjectModel;
using Stryker.Abstractions;
using Stryker.Abstractions.Mutants;
using Stryker.Abstractions.Options;
using Stryker.Configuration;
namespace Stryker.Core.Mutants;

--- Chunk 2 ---
public abstract class BaseMutantOrchestrator
{
    public readonly IStrykerOptions Options;
    private readonly IProvideId _idProvider;

    protected BaseMutantOrchestrator(IStrykerOptions options)
    {
        Options = options;
        _idProvider = Options.MutantIdProvider ?? new BasicIdProvider();
    }

    public bool MustInjectCoverageLogic =>
        Options != null && Options.OptimizationMode.HasFlag(OptimizationModes.CoverageBasedTest) &&
        !Options.OptimizationMode.HasFlag(OptimizationModes.CaptureCoveragePerTest);

        public ICollection<IMutant> Mutants { get; set; }

    protected int GetNextId() => _idProvider.NextId();

    /// <summary>
    /// Gets the stored mutants and resets the mutant list to an empty collection
    /// </summary>
    public virtual IReadOnlyCollection<IMutant> GetLatestMutantBatch()
    {
        var tempMutants = Mutants;
        Mutants = new Collection<IMutant>();
        return (IReadOnlyCollection<IMutant>)tempMutants;
    }
}


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.Logging;
using Stryker.Abstractions.Logging;
using Stryker.Abstractions.Mutants;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants;
/// <summary>
/// This enum is used to track the syntax 'level' of mutations that are injected in the code.
/// </summary>

--- Chunk 2 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 3 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 4 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 5 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 6 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 7 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 8 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 9 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 11 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Orchestrate mutation for Accessors (get/set). Its purpose is to convert arrow expression accessor to body statement form when needed.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Generic class to deal with syntax nodes which mutations must be injected at statement level
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// This purpose of each implementation of this class is to support one specific C# code construct during the mutation process.
/// Indeed, some constructs need to be handled specifically to ensure successful mutations.
/// Others are used to inject the need mutation control logic. It is strongly suggested to review each of those classes to
/// get a grasp of how they work before adding a new one.
/// </summary>
/// <typeparam name="TNode">Roslyn type which represents the C# construct</typeparam>
/// <typeparam name="TBase">Type of the node once mutated. In practice, either <see cref="TNode"/> or a base class of it.</typeparam>
/// <remarks>Those classes are an implementation of the 'Strategy' pattern. They must remain stateless, as the same instance is used for all syntax node of

--- Chunk 2 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 3 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 4 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 5 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 6 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 7 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// General handler for Statements. Remember to inherit from this class when you wand to create a statement specific logic.
/// </summary>
/// <typeparam name="T">Statement syntax type. Must inherit from <see cref="StatementSyntax"/></typeparam>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

using System.Collections.Generic;
using System.Collections.ObjectModel;
using Stryker.Abstractions;
using Stryker.Abstractions.Mutants;
using Stryker.Abstractions.Options;
using Stryker.Configuration;
namespace Stryker.Core.Mutants;

--- Chunk 2 ---
public abstract class BaseMutantOrchestrator
{
    public readonly IStrykerOptions Options;
    private readonly IProvideId _idProvider;

    protected BaseMutantOrchestrator(IStrykerOptions options)
    {
        Options = options;
        _idProvider = Options.MutantIdProvider ?? new BasicIdProvider();
    }

    public bool MustInjectCoverageLogic =>
        Options != null && Options.OptimizationMode.HasFlag(OptimizationModes.CoverageBasedTest) &&
        !Options.OptimizationMode.HasFlag(OptimizationModes.CaptureCoveragePerTest);

        public ICollection<IMutant> Mutants { get; set; }

    protected int GetNextId() => _idProvider.NextId();

    /// <summary>
    /// Gets the stored mutants and resets the mutant list to an empty collection
    /// </summary>
    public virtual IReadOnlyCollection<IMutant> GetLatestMutantBatch()
    {
        var tempMutants = Mutants;
        Mutants = new Collection<IMutant>();
        return (IReadOnlyCollection<IMutant>)tempMutants;
    }
}


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.Logging;
using Stryker.Abstractions.Logging;
using Stryker.Abstractions.Mutants;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants;
/// <summary>
/// This enum is used to track the syntax 'level' of mutations that are injected in the code.
/// </summary>

--- Chunk 2 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 3 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 4 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 5 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 6 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 7 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 8 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 9 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 11 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Orchestrate mutation for Accessors (get/set). Its purpose is to convert arrow expression accessor to body statement form when needed.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Generic class to deal with syntax nodes which mutations must be injected at statement level
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// This purpose of each implementation of this class is to support one specific C# code construct during the mutation process.
/// Indeed, some constructs need to be handled specifically to ensure successful mutations.
/// Others are used to inject the need mutation control logic. It is strongly suggested to review each of those classes to
/// get a grasp of how they work before adding a new one.
/// </summary>
/// <typeparam name="TNode">Roslyn type which represents the C# construct</typeparam>
/// <typeparam name="TBase">Type of the node once mutated. In practice, either <see cref="TNode"/> or a base class of it.</typeparam>
/// <remarks>Those classes are an implementation of the 'Strategy' pattern. They must remain stateless, as the same instance is used for all syntax node of

--- Chunk 2 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 3 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 4 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 5 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 6 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 7 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// General handler for Statements. Remember to inherit from this class when you wand to create a statement specific logic.
/// </summary>
/// <typeparam name="T">Statement syntax type. Must inherit from <see cref="StatementSyntax"/></typeparam>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

using System.Collections.Generic;
using System.Collections.ObjectModel;
using Stryker.Abstractions;
using Stryker.Abstractions.Mutants;
using Stryker.Abstractions.Options;
using Stryker.Configuration;
namespace Stryker.Core.Mutants;

--- Chunk 2 ---
public abstract class BaseMutantOrchestrator
{
    public readonly IStrykerOptions Options;
    private readonly IProvideId _idProvider;

    protected BaseMutantOrchestrator(IStrykerOptions options)
    {
        Options = options;
        _idProvider = Options.MutantIdProvider ?? new BasicIdProvider();
    }

    public bool MustInjectCoverageLogic =>
        Options != null && Options.OptimizationMode.HasFlag(OptimizationModes.CoverageBasedTest) &&
        !Options.OptimizationMode.HasFlag(OptimizationModes.CaptureCoveragePerTest);

        public ICollection<IMutant> Mutants { get; set; }

    protected int GetNextId() => _idProvider.NextId();

    /// <summary>
    /// Gets the stored mutants and resets the mutant list to an empty collection
    /// </summary>
    public virtual IReadOnlyCollection<IMutant> GetLatestMutantBatch()
    {
        var tempMutants = Mutants;
        Mutants = new Collection<IMutant>();
        return (IReadOnlyCollection<IMutant>)tempMutants;
    }
}


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.Logging;
using Stryker.Abstractions.Logging;
using Stryker.Abstractions.Mutants;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants;
/// <summary>
/// This enum is used to track the syntax 'level' of mutations that are injected in the code.
/// </summary>

--- Chunk 2 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 3 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 4 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 5 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 6 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 7 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 8 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 9 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 11 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Orchestrate mutation for Accessors (get/set). Its purpose is to convert arrow expression accessor to body statement form when needed.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Generic class to deal with syntax nodes which mutations must be injected at statement level
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// This purpose of each implementation of this class is to support one specific C# code construct during the mutation process.
/// Indeed, some constructs need to be handled specifically to ensure successful mutations.
/// Others are used to inject the need mutation control logic. It is strongly suggested to review each of those classes to
/// get a grasp of how they work before adding a new one.
/// </summary>
/// <typeparam name="TNode">Roslyn type which represents the C# construct</typeparam>
/// <typeparam name="TBase">Type of the node once mutated. In practice, either <see cref="TNode"/> or a base class of it.</typeparam>
/// <remarks>Those classes are an implementation of the 'Strategy' pattern. They must remain stateless, as the same instance is used for all syntax node of

--- Chunk 2 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 3 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 4 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 5 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 6 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 7 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// General handler for Statements. Remember to inherit from this class when you wand to create a statement specific logic.
/// </summary>
/// <typeparam name="T">Statement syntax type. Must inherit from <see cref="StatementSyntax"/></typeparam>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

using System.Collections.Generic;
using System.Collections.ObjectModel;
using Stryker.Abstractions;
using Stryker.Abstractions.Mutants;
using Stryker.Abstractions.Options;
using Stryker.Configuration;
namespace Stryker.Core.Mutants;

--- Chunk 2 ---
public abstract class BaseMutantOrchestrator
{
    public readonly IStrykerOptions Options;
    private readonly IProvideId _idProvider;

    protected BaseMutantOrchestrator(IStrykerOptions options)
    {
        Options = options;
        _idProvider = Options.MutantIdProvider ?? new BasicIdProvider();
    }

    public bool MustInjectCoverageLogic =>
        Options != null && Options.OptimizationMode.HasFlag(OptimizationModes.CoverageBasedTest) &&
        !Options.OptimizationMode.HasFlag(OptimizationModes.CaptureCoveragePerTest);

        public ICollection<IMutant> Mutants { get; set; }

    protected int GetNextId() => _idProvider.NextId();

    /// <summary>
    /// Gets the stored mutants and resets the mutant list to an empty collection
    /// </summary>
    public virtual IReadOnlyCollection<IMutant> GetLatestMutantBatch()
    {
        var tempMutants = Mutants;
        Mutants = new Collection<IMutant>();
        return (IReadOnlyCollection<IMutant>)tempMutants;
    }
}


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,


===== New File Processed =====

--- Chunk 1 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

[
new DoNotMutateOrchestrator<AttributeListSyntax>()
,
// parameter list
new DoNotMutateOrchestrator<ParameterListSyntax>()
,
// enum values
new DoNotMutateOrchestrator<EnumMemberDeclarationSyntax>()
,
new DoNotMutateOrchestrator<UsingDirectiveSyntax>()
,
// constants and constant fields
new DoNotMutateOrchestrator<FieldDeclarationSyntax>(
            t => t.Modifiers.Any(x => x.IsKind(SyntaxKind.ConstKeyword)))
,
new DoNotMutateOrchestrator<LocalDeclarationStatementSyntax>(t => t.IsConst)
,
// ensure pre/post increment/decrement mutations are mutated at statement level
new MutateAtStatementLevelOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
new MutateAtStatementLevelOrchestrator<PrefixUnaryExpressionSyntax>(t =>
            t.Parent is ExpressionStatementSyntax or ForStatementSyntax)
,
// prevent mutations to happen within member access expression

--- Chunk 2 ---
new MemberAccessExpressionOrchestrator<MemberAccessExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<MemberBindingExpressionSyntax>()
,
new MemberAccessExpressionOrchestrator<SimpleNameSyntax>()
,
new MemberAccessExpressionOrchestrator<PostfixUnaryExpressionSyntax>(t =>
            t.IsKind(SyntaxKind.SuppressNullableWarningExpression))
,
// ensure pattern syntax nodes are mutated (as they are neither expression nor statements, they are not mutated by default)
new NodeSpecificOrchestrator<PatternSyntax, PatternSyntax>()
,
new NodeSpecificOrchestrator<SubpatternSyntax, SubpatternSyntax>()
,
new ConditionalExpressionOrchestrator()
,
new ConstantPatternSyntaxOrchestrator()
,
// ensure static constructs are marked properly
new StaticFieldDeclarationOrchestrator()
,
new StaticConstructorOrchestrator()
,
// ensure array initializer mutations are controlled at statement level

--- Chunk 3 ---
new MutateAtStatementLevelOrchestrator<InitializerExpressionSyntax>(t =>
            t.Kind() == SyntaxKind.ArrayInitializerExpression && t.Expressions.Count > 0)
,
// ensure properties are properly mutated (including expression to body conversion if required)
new ExpressionBodiedPropertyOrchestrator()
,
// ensure method, lambda... are properly mutated (including expression to body conversion if required)
new LocalFunctionStatementOrchestrator()
,
new AnonymousFunctionExpressionOrchestrator()
,
new BaseMethodDeclarationOrchestrator<BaseMethodDeclarationSyntax>()
,
new AccessorSyntaxOrchestrator()
,
// ensure declaration are mutated at the block level
new LocalDeclarationOrchestrator()
,
new InvocationExpressionOrchestrator()
,
new NodeSpecificOrchestrator<GlobalStatementSyntax, GlobalStatementSyntax>()
,
new MemberDefinitionOrchestrator<MemberDeclarationSyntax>()
,
new MutateAtStatementLevelOrchestrator<AssignmentExpressionSyntax>()
,
new BlockOrchestrator()
,

--- Chunk 4 ---

{
private static readonly TypeBasedStrategy<SyntaxNode, INodeOrchestrator> specificOrchestrator =
        new();
private ILogger Logger { get; }
static CsharpMutantOrchestrator() =>
    // declare node specific orchestrators. Note that order is relevant, they should be declared from more specific to more generic one
        specificOrchestrator.RegisterHandlers(BuildOrchestratorList());
/// <summary>
/// <param name="mutators">The mutators that should be active during the mutation process</param>
/// </summary>
public CsharpMutantOrchestrator(MutantPlacer placer, IEnumerable<IMutator> mutators = null, IStrykerOptions options = null) : base(options)
    {
        Placer = placer;
        Mutators = mutators ?? DefaultMutatorList();
        Mutants = new Collection<IMutant>();
        Logger = ApplicationLogging.LoggerFactory.CreateLogger<CsharpMutantOrchestrator>();
    }

--- Chunk 5 ---
private static List<IMutator> DefaultMutatorList() =>
    [
        new BinaryExpressionMutator(),
        new RelationalPatternMutator(),
        new BinaryPatternMutator(),
        new StringMethodMutator(),
        new StringMethodToConstantMutator(),
        new BlockMutator(),
        new BooleanMutator(),
        new ConditionalExpressionMutator(),
        new AssignmentExpressionMutator(),
        new PrefixUnaryMutator(),
        new PostfixUnaryMutator(),
        new CheckedMutator(),
        new LinqMutator(),
        new StringMutator(),
        new StringEmptyMutator(),
        new InterpolatedStringMutator(),
        new NegateConditionMutator(),
        new InitializerMutator(),
        new ObjectCreationMutator(),
        new ArrayCreationMutator(),
        new StatementMutator(),
        new RegexMutator(),
        new NullCoalescingExpressionMutator(),
        new MathMutator(),
        new IsPatternExpressionMutator(),
        new CollectionExpressionMutator(),
    ];

--- Chunk 6 ---

internal
IEnumerable<Mutant>
GenerateMutationsForNode
(SyntaxNode current, SemanticModel semanticModel, MutationContext context)

--- Chunk 7 ---
private IEnumerable<IMutator> Mutators { get; }
public MutantPlacer Placer { get; }
/// <summary>
/// Recursively mutates a syntax tree
/// </summary>
/// <param name="input">The syntax tree to mutate</param>
/// <param name="semanticModel">Associated semantic model</param>
/// <returns>Mutated tree</returns>
public override SyntaxTree Mutate(SyntaxTree input, SemanticModel semanticModel) =>
        // search for node specific handler
        input.WithRootAndOptions(GetHandler(input.GetRoot()).Mutate(input.GetRoot(), semanticModel, new MutationContext(this)), input.Options);
internal INodeOrchestrator GetHandler(SyntaxNode currentNode) => specificOrchestrator.FindHandler(currentNode);
/// <summary>
/// Creates a new mutant for the given mutation, mutator and context. Returns null if the mutant
/// is a duplicate.
/// </summary>

--- Chunk 8 ---
private Mutant CreateNewMutant(Mutation mutation, MutationContext context)
    {
        var mutantIgnored = context.FilteredMutators?.Contains(mutation.Type) ?? false;
        return new Mutant
        {
            Mutation = mutation,
            ResultStatus = mutantIgnored ? MutantStatus.Ignored : MutantStatus.Pending,
            IsStaticValue = context.InStaticValue,
            ResultStatusReason = mutantIgnored ? context.FilterComment : null
        };
    }
/// <summary>
/// Returns true if the new mutant is a duplicate of a mutant already listed in Mutants.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====

--- Chunk 1 ---

{
public int Id { get; set; }
public Mutation Mutation { get; set; }
public MutantStatus ResultStatus { get; set; }
public ITestGuids CoveringTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids KillingTests { get; set; } = TestGuidsList.NoTest();
public ITestGuids AssessingTests { get; set; } = TestGuidsList.EveryTest();
public string ResultStatusReason { get; set; }
public bool CountForStats => ResultStatus != MutantStatus.CompileError && ResultStatus != MutantStatus.Ignored;
public bool IsStaticValue { get; set; }
public bool MustBeTestedInIsolation { get; set; }
public string DisplayName => $"{Id}: {Mutation?.DisplayName}";


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
private const string MutationIdMarker = "MutationId";
private const string MutationTypeMarker = "MutationType";
public static readonly string Injector = "Injector";
private static readonly Dictionary<string, (IInstrumentCode engine, SyntaxAnnotation annotation)> instrumentEngines = [];
private static readonly HashSet<string> requireRecursiveRemoval = [];
private static readonly StaticInstrumentationEngine StaticEngine = new();
private static readonly StaticInitializerMarkerEngine StaticInitializerEngine = new();
private static readonly IfInstrumentationEngine IfEngine = new();
private static readonly ConditionalInstrumentationEngine ConditionalEngine = new();
private static readonly EndingReturnEngine EndingReturnEngine = new();
private static readonly DefaultInitializationEngine DefaultInitializationEngine = new();
private readonly CodeInjection _injection;
private ExpressionSyntax _binaryExpression;
private SyntaxNode _placeHolderNode;

--- Chunk 2 ---

public
static
SyntaxAnnotation
RegisterEngine
(IInstrumentCode engine, bool requireRecursive = false)

--- Chunk 3 ---
public static IEnumerable<string> MutationMarkers => [MutationIdMarker, MutationTypeMarker, Injector];
public MutantPlacer(CodeInjection injection) => _injection = injection;
/// <summary>
/// Register an instrumentation engine
/// </summary>
/// <param name="engine">engine to register</param>
/// <param name="requireRecursive">true if inner injections should be removed first.</param>
/// <summary>
/// Add a return at the end of the syntax block, assuming it appears to be useful and returns the new block.
/// </summary>
/// <param name="block">block to complete with an ending return</param>
/// <param name="propertyType">type to return. if null, ends the statement block with a non-typed 'return default'.</param>
/// <returns><paramref name="block"/> with an extra return or not</returns>

--- Chunk 4 ---
/// <remarks>The engine verifies if a return may be useful and does not inject it otherwise. For example, it does nothing if the block is empty, return type is void or if the block already ends with a return or a throw statement.</remarks>
public static BlockSyntax AddEndingReturn(BlockSyntax block, TypeSyntax propertyType) =>
        EndingReturnEngine.InjectReturn(block, propertyType);
/// <summary>
/// Adds a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="block">block to augment with the marker</param>
/// <returns><paramref name="block"/> with the marker added via a using statement.</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        StaticEngine.PlaceStaticContextMarker(block, _injection);
/// <summary>
/// Add a static marker so that Stryker can identify mutations used in static context
/// </summary>
/// <param name="expression">expression to augment with the marker</param>

--- Chunk 5 ---
/// <returns><paramref name="expression"/> with the marker added via a using expression.</returns>
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        StaticInitializerEngine.PlaceValueMarker(expression, _injection);
/// <summary>
/// Add initialization for all out parameters
/// </summary>
/// <param name="block">block to augment with an initialization block</param>
/// <param name="parameters"></param>
/// <returns><paramref name="block"/> with assignment statements in a block.</returns>
/// <remarks>return <paramref name="block"/> if there is no 'out' parameter.</remarks>
public static BlockSyntax InjectOutParametersInitialization(BlockSyntax block, IEnumerable<ParameterSyntax> parameters) =>
        DefaultInitializationEngine.InjectOutParametersInitialization(block, parameters);
/// <summary>
/// Add one or more mutations controlled via one or more if statements
/// </summary>

--- Chunk 6 ---
/// <param name="original">original statement (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>an if statement (or a chain of if statements) containing the mutant(s) and the original node.</returns>
public StatementSyntax PlaceStatementControlledMutations(StatementSyntax original,
        IEnumerable<(Mutant mutant, StatementSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (syntaxNode, mutationInfo) =>
            IfEngine.InjectIf(GetBinaryExpression(mutationInfo.mutant.Id), syntaxNode, mutationInfo.mutation)
                // Mark this node as a MutationIf node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>

--- Chunk 7 ---
/// Add one or more mutations controlled via one or more ternary operators
/// </summary>
/// <param name="original">original expression (will be used to generate mutations)</param>
/// <param name="mutants">list of mutations to inject</param>
/// <returns>a ternary expression (or a chain of ternary expression) containing the mutant(s) and the original node.</returns>

--- Chunk 8 ---
public ExpressionSyntax PlaceExpressionControlledMutations(ExpressionSyntax original,
        IEnumerable<(Mutant mutant, ExpressionSyntax mutation)> mutants) =>
        mutants.Aggregate(original, (current, mutationInfo) =>
            ConditionalEngine.PlaceWithConditionalExpression(GetBinaryExpression(mutationInfo.mutant.Id), current, mutationInfo.mutation)
                // Mark this node as a MutationConditional node. Store the MutantId in the annotation to retrace the mutant later
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationIdMarker, mutationInfo.mutant.Id.ToString()))
                .WithAdditionalAnnotations(new SyntaxAnnotation(MutationTypeMarker, mutationInfo.mutant.Mutation.Type.ToString())));
/// <summary>
/// Removes the mutant (or injected code) from the syntax node
/// </summary>
/// <param name="nodeToRemove"></param>
/// <returns>the node without any injection</returns>

--- Chunk 9 ---
/// <remarks>only remove injection for <paramref name="nodeToRemove"/> and keep any child one.</remarks>
/// <exception cref="InvalidOperationException">if there is no trace of a code injection</exception>
public static SyntaxNode RemoveMutant(SyntaxNode nodeToRemove)
    {
        var annotatedNode = nodeToRemove.GetAnnotatedNodes(Injector).FirstOrDefault();
        if (annotatedNode != null)
        {
            var id = annotatedNode.GetAnnotations(Injector).First().Data;
            if (!string.IsNullOrEmpty(id))
            {
                var restoredNode = instrumentEngines[id].engine.RemoveInstrumentation(annotatedNode);
                return annotatedNode == nodeToRemove ? restoredNode : nodeToRemove.ReplaceNode(annotatedNode, restoredNode);
            }
        }
        throw new InvalidOperationException($"Unable to find an engine to remove injection from this node: '{nodeToRemove}'");
    }
/// <summary>

--- Chunk 10 ---
/// Returns true if the node contains a mutation requiring all child mutations to be removed when it has to be removed
/// </summary>
/// <param name="node"></param>
/// <returns></returns>
public static bool RequiresRemovingChildMutations(SyntaxNode node)
    {
        var annotations = node.GetAnnotations(MutationMarkers).ToList();
        if (annotations.TrueForAll(a => a.Kind != Injector))
        {
            throw new InvalidOperationException("No mutation in this node!");
        }
        return annotations.Exists(a => requireRecursiveRemoval.Contains(a.Data));
    }
/// <summary>
/// Gets mutant related annotations from a syntax node
/// </summary>
/// <param name="node"></param>
/// <returns></returns>

--- Chunk 11 ---
public static MutantInfo FindAnnotations(SyntaxNode node)
    {
        var id = -1;
        string engine = null;
        string type = null;
        var annotations = node.GetAnnotations(MutationMarkers);
        foreach (var annotation in annotations)
        {
            if (annotation.Kind == MutationIdMarker)
            {
                id = int.Parse(annotation.Data!);
            }
            else if (annotation.Kind == Injector)
            {
                engine = annotation.Data;
            }
            else if (annotation.Kind == MutationTypeMarker)
            {
                type = annotation.Data;
            }
        }

        return new MutantInfo
        {
            Id = id,
            Engine = engine,
            Type = type,
            Node = node
        };
    }
/// <summary>
/// Builds a syntax for the expression to check if a mutation is active
/// Example for mutationId 1: Stryker.Helper.ActiveMutation == 1
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
// main orchestrator
// the orchestrator is used to perform actual mutation injections
private readonly CsharpMutantOrchestrator _mainOrchestrator;
// pending mutation stacks. An entry is pushed in the stack when entering a member or function and popping it when leaving
private readonly MutationStore _mutation;
/// <summary>
/// Mutation context must be created once when starting a mutation process.
/// </summary>
/// <param name="mutantOrchestrator"></param>
public MutationContext(CsharpMutantOrchestrator mutantOrchestrator)
    {
        _mainOrchestrator = mutantOrchestrator;
        _mutation = new MutationStore(mutantOrchestrator.Placer);
    }
private MutationContext(MutationContext parent)
    {
        _mainOrchestrator = parent._mainOrchestrator;
        InStaticValue = parent.InStaticValue;
        _mutation = parent._mutation;
        FilteredMutators = parent.FilteredMutators;
        FilterComment = parent.FilterComment;
    }
/// <summary>

--- Chunk 2 ---
///  True when inside a static initializer, fields or accessor.
/// </summary>
public bool InStaticValue { get; private init; }
/// <summary>
/// True if orchestrator have to inject static usage tracing
/// </summary>
public bool MustInjectCoverageLogic => _mainOrchestrator.MustInjectCoverageLogic;
internal Mutator[] FilteredMutators { get; private set; }
internal string FilterComment { get; set; }
/// <summary>
/// true if there are pending statement or block level mutations
/// </summary>
public bool HasLeftOverMutations => _mutation.HasPendingMutations();
/// <summary>
/// Returns the current mutation control level
/// </summary>
public MutationControl CurrentControl => _mutation.CurrentControl;
/// <summary>
/// Call this to generate mutations using active mutators.
/// </summary>
/// <param name="node"><see cref="SyntaxNode"/> to mutate.</param>
/// <param name="semanticModel">current semantic model</param>
/// <returns>A list of mutants.</returns>

--- Chunk 3 ---
public IEnumerable<Mutant> GenerateMutantsForNode(SyntaxNode node, SemanticModel semanticModel) =>
        _mainOrchestrator.GenerateMutationsForNode(node, semanticModel, this);
/// <summary>
/// Find the appropriate node handler for the given node.
/// </summary>
/// <param name="node">handler for which to find an orchestrator.</param>
/// <param name="model"></param>
/// <returns>A handler for this node.</returns>
public SyntaxNode Mutate(SyntaxNode node, SemanticModel model) => _mainOrchestrator.GetHandler(node).Mutate(node, model, this);
/// <summary>
/// Call this to signal mutation occurs in static method or fields
/// </summary>
/// <returns>A new context</returns>
public MutationContext EnterStatic() => new(this) { InStaticValue = true };
/// <summary>
/// Call this when beginning of a syntax structure that can control mutations (expression, statement, block)
/// </summary>
/// <param name="control">type of structure (see <see cref="MutationControl"/>)</param>

--- Chunk 4 ---
/// <returns>The context to use moving forward.</returns>
/// <remarks>You must use <see cref="Leave()"/>when leaving the context.</remarks>
public MutationContext Enter(MutationControl control)
    {
        _mutation.Enter(control);
        return control is MutationControl.Block or MutationControl.Member ? new MutationContext(this) : this;
    }
public MutationContext BlockInjection()
    {
        _mutation.BlockInjection();
        return this;
    }
public MutationContext EnableInjection()
    {
        _mutation.EnableInjection();
        return this;
    }
/// <summary>
/// Call this when leaving a control syntax structure
/// </summary>
/// <remarks>A call must match a previous call to <see cref="Enter(MutationControl)"/></remarks>
public MutationContext Leave()
    {
        _mutation.Leave();
        return this;
    }
/// <summary>
/// Register mutations
/// </summary>
/// <param name="mutants"></param>

--- Chunk 5 ---
public MutationContext AddMutations(IEnumerable<Mutant> mutants)
    {
        _mutation.StoreMutations(mutants);
        return this;
    }
/// <summary>
/// Register new block level mutations
/// </summary>
/// <param name="mutants"></param>
/// <param name="control"></param>
public MutationContext AddMutations(IEnumerable<Mutant> mutants, MutationControl control)
    {
        _mutation.StoreMutationsAtDesiredLevel(mutants, control);
        return this;
    }
/// <summary>
/// Inject a static context marker in the given block
/// </summary>
/// <param name="block">Block in which inserts the marker</param>
/// <returns>the updated block</returns>
public BlockSyntax PlaceStaticContextMarker(BlockSyntax block) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(block);
/// <summary>
/// Inject a static context marker in the given expression
/// </summary>
/// <param name="expression">expression in which inserts the marker</param>
/// <returns>the updated expression</returns>

--- Chunk 6 ---
public ExpressionSyntax PlaceStaticContextMarker(ExpressionSyntax expression) =>
        _mainOrchestrator.Placer.PlaceStaticContextMarker(expression);
/// <summary>
/// Injects pending expression level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
/// <remarks>Do not inject mutation(s) if in a subexpression</remarks>
public ExpressionSyntax InjectMutations(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode) => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending statement level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>

--- Chunk 7 ---
public StatementSyntax InjectMutations(StatementSyntax mutatedNode, StatementSyntax sourceNode)
        => _mutation.Inject(mutatedNode, sourceNode);
/// <summary>
/// Injects pending block level mutations.
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="sourceNode">Source node, used to generate mutations</param>
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode, BlockSyntax sourceNode) =>
        _mutation.Inject(mutatedNode, sourceNode);
/// <summary>s
/// Injects pending block level mutations for expression body method or functions
/// </summary>
/// <param name="mutatedNode">Target node that will contain the mutations</param>
/// <param name="originalNode">Source node, used to generate mutations</param>
/// <param name="needReturn">Set to true if the method has a return value. Expressions are transformed to return statement.</param>

--- Chunk 8 ---
/// <returns>A mutated node containing the mutations.</returns>
public BlockSyntax InjectMutations(BlockSyntax mutatedNode,
        ExpressionSyntax originalNode, bool needReturn) =>
        _mutation.Inject(mutatedNode, originalNode, needReturn);
/// <summary>
/// Enable/Disable a list of mutators.
/// </summary>
/// <param name="mode">true to disable mutators, false to (re)enable some</param>
/// <param name="filteredMutators">list of mutators</param>
/// <param name="newContext">true to create a new context</param>
/// <param name="comment">comment used for ignored mutators</param>
/// <returns>a context with an updated list of active mutators</returns>


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 2 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 3 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 4 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 5 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 6 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 7 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 8 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 9 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.Logging;
using Stryker.Abstractions.Logging;
using Stryker.Abstractions.Mutants;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants;
/// <summary>
/// This enum is used to track the syntax 'level' of mutations that are injected in the code.
/// </summary>

--- Chunk 2 ---

{
protected static readonly ILogger Logger = ApplicationLogging.LoggerFactory.CreateLogger<MutationStore>();
private readonly MutantPlacer _mutantPlacer;
private readonly Stack<PendingMutations> _pendingMutations = new();
private int _injectionBlockCounter;
/// <summary>
/// Constructor
/// </summary>
/// <param name="mutantPlacer">Mutant placer that will be used for mutation injection</param>
public MutationStore(MutantPlacer mutantPlacer) => _mutantPlacer = mutantPlacer;
/// <summary>
/// Checks if there are pending mutations for the current syntax level
/// </summary>
/// <returns></returns>
public bool HasPendingMutations() => _pendingMutations.Count > 0 && _pendingMutations.Peek().Store.Count > 0;
/// <summary>
/// Returns the current mutation control
/// </summary>
public MutationControl CurrentControl => _pendingMutations.Count > 0 ? _pendingMutations.Peek().Control : MutationControl.Member;
/// <summary>
/// Enter a syntax level
/// </summary>

--- Chunk 3 ---
/// <param name="control">syntax level (should match current node level) <see cref="MutationControl"/></param>
public void Enter(MutationControl control)
    {
        // we use a simple logic to keep the stack small: if the current level is the same as the previous one, we just increment the depth
        if (_pendingMutations.Count > 0 && _pendingMutations.Peek().Aggregate(control))
        {
            return;
        }
        _pendingMutations.Push(new PendingMutations(control));
    }
/// <summary>
/// Leave current syntax construct
/// </summary>
/// <remarks>Any non injected mutations will be forwarded to the enclosing syntax construct.
/// If there is none (leaving a member), mutations are flagged as compile errors (and logged).</remarks>

--- Chunk 4 ---
public void Leave()
    {
        if (!_pendingMutations.Peek().Leave())
        {
            return;
        }
        // we need to store pending mutations at the higher level
        var old = _pendingMutations.Pop();
        if (_pendingMutations.Count > 0)
        {
            _pendingMutations.Peek().StoreMutations(old.Store);
        }
        else if (old.Store.Count > 0)
        {
            Logger.LogDebug("{MutationsCount} mutation(s) could not be injected, they are dropped.", old.Store.Count);
            foreach (var mutant in old.Store)
            {
                mutant.ResultStatus = MutantStatus.CompileError;
                mutant.ResultStatusReason = "Could not be injected in code.";
            }
        }
    }
/// <summary>
/// Prevent any mutation injection
/// </summary>
/// <remarks>This method is typically used for constant syntax node, where mutations need to be controlled at a higher syntax level.</remarks>

--- Chunk 5 ---
public void BlockInjection() => _injectionBlockCounter++;
/// <summary>
/// Restore mutation injection
/// </summary>
public void EnableInjection() => _injectionBlockCounter--;
private PendingMutations FindControl(MutationControl control) => _pendingMutations.FirstOrDefault(item => item.Control >= control);
/// <summary>
/// Stores mutations at the given syntax level to be injected at a later time
/// </summary>
/// <param name="store">mutants to store</param>
/// <param name="level">requested control level</param>
/// <returns>true if insertion is successful</returns>
/// <remarks>Mutants may be stored in a higher level construct if the desired level is nonexistent. If insertion fails, mutants are flagged
/// as compile error and logged.</remarks>

--- Chunk 6 ---
public bool StoreMutationsAtDesiredLevel(IEnumerable<Mutant> store, MutationControl level)
    {
        if (!store.Any())
        {
            return true;
        }

        var controller = FindControl(level);

        if (controller != null)
        {
            controller.StoreMutations(store);
            return true;
        }
        Logger.LogDebug("There is no structure to control {MutationsCount} mutations. They are dropped.", store.Count());
        foreach (var mutant in store)
        {
            mutant.ResultStatus = MutantStatus.CompileError;
            mutant.ResultStatusReason = "Could not be injected in code.";
        }
        return false;
    }
/// <summary>
/// Store mutations at current syntax level to be injected at a later time
/// </summary>
/// <param name="store"></param>
/// <returns></returns>

--- Chunk 7 ---
public bool StoreMutations(IEnumerable<Mutant> store)
    {
        if (_pendingMutations.Count == 0)
        {
            return false;
        }
        _pendingMutations.Peek().StoreMutations(store);
        return true;
    }
/// <summary>
/// Inject (current level) mutations inside the provided expression (controlled with ternary operator)
/// </summary>
/// <param name="mutatedNode">mutated expression</param>
/// <param name="sourceNode">original node</param>
/// <returns>a syntax expression with the mutations included </returns>

--- Chunk 8 ---
public ExpressionSyntax Inject(ExpressionSyntax mutatedNode, ExpressionSyntax sourceNode)
    {
        if (_injectionBlockCounter > 0 || _pendingMutations.Peek().Control == MutationControl.MemberAccess)
        {
            // do not inject if explicitly blocked
            // never inject at member access level, there is no known control structure
            return mutatedNode;
        }
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceExpressionControlledMutations(mutatedNode,
             store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided statement (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated statement</param>
/// <param name="sourceNode">original node</param>

--- Chunk 9 ---
/// <returns>a statement with the mutations included. It should be an 'if' statement when at least one mutation was provided </returns>
public StatementSyntax Inject(StatementSyntax mutatedNode, StatementSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, sourceNode.InjectMutation(m.Mutation))));
        store.Clear();
        return result;
    }
/// <summary>
/// Inject (current level) mutations in the provided block (controlled with if statement)
/// </summary>
/// <param name="mutatedNode">mutated block</param>
/// <param name="sourceNode">original node</param>
/// <returns>a block with the mutations included.</returns>

--- Chunk 10 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, BlockSyntax sourceNode)
    {
        var store = _pendingMutations.Peek().Store;
        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            store.Select(m => (m, ((StatementSyntax)sourceNode).InjectMutation(m.Mutation))));
        store.Clear();

        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }
/// <summary>
/// Inject mutations within the provided expression body and return them as a block syntax.
/// </summary>
/// <param name="mutatedNode">target node</param>
/// <param name="originalNode">original expression body</param>
/// <param name="needReturn">true if the expression body has a return value</param>
/// <returns>a block syntax with the mutated expression body converted to statement(s).</returns>
/// <remarks>This method should be used when mutating expression body methods or functions</remarks>

--- Chunk 11 ---
public BlockSyntax Inject(BlockSyntax mutatedNode, ExpressionSyntax originalNode, bool needReturn)
    {
        var wrapper = needReturn
            ? (Func<ExpressionSyntax, StatementSyntax>)SyntaxFactory.ReturnStatement
            : SyntaxFactory.ExpressionStatement;

        var blockStore = _pendingMutations.Peek();
        if (blockStore.Store.Count == 0)
        {
            return mutatedNode;
        }

        var result = _mutantPlacer.PlaceStatementControlledMutations(mutatedNode,
            blockStore.Store.Select(m => (m, wrapper(originalNode.InjectMutation(m.Mutation)))));
        blockStore.Store.Clear();
        return result as BlockSyntax ?? SyntaxFactory.Block(result);
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly HashSet<Guid> _testGuids;
private static readonly TestGuidsList EveryTests = new();
private static readonly TestGuidsList NoTestAtAll = new(Array.Empty<Guid>());
private TestGuidsList() => _testGuids = null;
public TestGuidsList(IEnumerable<TestDescription> testDescriptions) : this(testDescriptions?.Select(t => t.Id))
    { }
public TestGuidsList(HashSet<Guid> set) => _testGuids = set;
public TestGuidsList(IEnumerable<Guid> guids) => _testGuids = guids != null ? new HashSet<Guid>(guids) : null;
public TestGuidsList(params Guid[] guids) : this((IEnumerable<Guid>)guids)
    { }
public bool IsEmpty => _testGuids is { Count: 0 };
public bool IsEveryTest => _testGuids == null;
public int Count => _testGuids?.Count ?? 0;

--- Chunk 2 ---
public ITestGuids Merge(ITestGuids other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public TestGuidsList Merge(TestGuidsList other)
    {
        if (IsEveryTest)
        {
            return this;
        }

        var result = new HashSet<Guid>(_testGuids);
        result.UnionWith(other.GetGuids());
        return new TestGuidsList(result);
    }
public bool Contains(Guid testId) => IsEveryTest || _testGuids.Contains(testId);
public bool IsIncludedIn(ITestGuids other) => other.IsEveryTest || _testGuids?.IsSubsetOf(other.GetGuids()) == true;

--- Chunk 3 ---
public TestGuidsList Excluding(TestGuidsList testsToSkip)
    {
        if (IsEmpty || testsToSkip.IsEmpty)
        {
            return this;
        }

        if (IsEveryTest)
        {
            throw new InvalidOperationException("Can't exclude from EveryTest");
        }

        return testsToSkip.IsEveryTest ? NoTest() : new TestGuidsList(_testGuids.Except(testsToSkip._testGuids));
    }
public static TestGuidsList EveryTest() => EveryTests;
public static TestGuidsList NoTest() => NoTestAtAll;
public IEnumerable<Guid> GetGuids() => _testGuids ?? [];
public bool ContainsAny(ITestGuids other)
    {
        if (other.IsEmpty || IsEmpty)
        {
            return false;
        }
        if (IsEveryTest || other.IsEveryTest)
        {
            return true;
        }
        return _testGuids.Overlaps(other.GetGuids());
    }


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly IEnumerable<Guid> _guids;
public ICollection<TestDescription> Tests => throw new NotImplementedException();
public int Count => _guids.Count();
public bool IsEmpty => _guids == null || !_guids.Any();
public bool IsEveryTest => false;
public ITestGuids Merge(ITestGuids other) => MergeList(this, other);
public bool Contains(Guid testId) => _guids.Any(g => g == testId);
public bool ContainsAny(ITestGuids other) => _guids.Any(other.Contains);
public bool IsIncludedIn(ITestGuids other) => _guids.All(other.Contains);
public WrappedGuidsEnumeration(IEnumerable<Guid> guids) => _guids = guids;
public ITestGuids Excluding(ISet<Guid> testsToSkip) => IsEveryTest || IsEmpty ? this : new TestGuidsList(_guids.Except(testsToSkip));


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Helpers;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Orchestrate mutation for Accessors (get/set). Its purpose is to convert arrow expression accessor to body statement form when needed.
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(AnonymousFunctionExpressionSyntax node) => (node.Block, node.ExpressionBody);
protected override ParameterListSyntax ParameterList(AnonymousFunctionExpressionSyntax node) => node switch {ParenthesizedLambdaExpressionSyntax parenthesizedLambda => parenthesizedLambda.ParameterList,
        SimpleLambdaExpressionSyntax simpleLambda => SyntaxFactory.ParameterList(SyntaxFactory.SingletonSeparatedList(simpleLambda.Parameter)),
        AnonymousMethodExpressionSyntax anonymousMethod => anonymousMethod.ParameterList,
        _ => throw new ArgumentOutOfRangeException(nameof(node), node, null)
    };
protected override TypeSyntax ReturnType(AnonymousFunctionExpressionSyntax node) => null;


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 2 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
private readonly SeparatedSyntaxList<ParameterSyntax> _emptyParameterList;
protected BaseFunctionOrchestrator()
    {
        Marker = MutantPlacer.RegisterEngine(this, true);
        _emptyParameterList = SyntaxFactory.SeparatedList<ParameterSyntax>();
    }
private SyntaxAnnotation Marker { get; }
/// <inheritdoc/>
public string InstrumentEngineId => GetType().Name;
/// <summary>
/// Get the function body (block or expression)
/// </summary>
/// <param name="node"></param>
/// <returns>a tuple with the block body as first item and the expression body as the second. At least one of them is expected to be null.</returns>
protected abstract (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node);
/// <summary>
/// Gets the parameter list of the function
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>a parameter list</returns>
protected abstract ParameterListSyntax ParameterList(T node);
/// <summary>
/// Get the return type

--- Chunk 2 ---
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <returns>return type of the function</returns>
protected abstract TypeSyntax ReturnType(T node);
/// <summary>
/// Use the provided syntax block for the body of the function (set the expression body part to null)
/// </summary>
/// <param name="node">instance of <see cref="T"/></param>
/// <param name="blockBody">desired body</param>
/// <param name="expressionBody">desired expression body</param>
/// <returns>an instance of <typeparamref name="T"/> with <paramref name="blockBody"/> body</returns>
protected abstract T SwitchToThisBodies(T node, BlockSyntax blockBody, ExpressionSyntax expressionBody);

--- Chunk 3 ---
private static BlockSyntax GenerateBlockBody(ExpressionSyntax expressionBody, TypeSyntax returnType)
    {
        StatementSyntax statementLine = returnType.IsVoid()
            ? SyntaxFactory.ExpressionStatement(expressionBody)
            : SyntaxFactory.ReturnStatement(expressionBody.WithLeadingTrivia(SyntaxFactory.Space));

        var result = SyntaxFactory.Block(statementLine);
        return result;
    }
public T ConvertToBlockBody(T node) => ConvertToBlockBody(node, ReturnType(node));
protected T ConvertToBlockBody(T node, TypeSyntax returnType)
    {
        var (block, expression) = GetBodies(node);
        if (block != null)
        {
            return node;
        }
        var blockBody = GenerateBlockBody(expression, returnType);
        return SwitchToThisBodies(node, blockBody, null).WithAdditionalAnnotations(Marker);
    }
/// <inheritdoc/>

--- Chunk 4 ---

{
var (blockBody, expressionBody) = GetBodies(targetNode);
if (expressionBody == null && blockBody == null)
        {
            // no implementation provided
            return targetNode;
        }
var wasInExpressionForm = GetBodies(sourceNode).expression != null;
var returnType = ReturnType(sourceNode);
var parameters = ParameterList(sourceNode)?.Parameters ?? _emptyParameterList;
// no mutations to inject

--- Chunk 5 ---
if (!context.HasLeftOverMutations)
        {
            if (blockBody == null)
            {
                // we can't do any other injection
                return targetNode;
            }

            var originalBody = blockBody;
            // inject default initializers (if any)
            blockBody = MutantPlacer.InjectOutParametersInitialization(blockBody, parameters);
            if (!wasInExpressionForm)
            {
                // add ending return (to mitigate compilation error due to control flow change)
                // not needed for an expression form method as no control flow may be present
                blockBody = MutantPlacer.AddEndingReturn(blockBody, returnType);
            }
            // do we need to change the body
            return originalBody == blockBody ? targetNode : SwitchToThisBodies(targetNode, MutantPlacer.AddEndingReturn(blockBody, returnType), null);
        }
targetNode = ConvertToBlockBody(targetNode, returnType);


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(T node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(T node) => node.ParameterList;
protected override TypeSyntax ReturnType(T node)
    {
        var returnType = node.ReturnType();
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType().DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

public
static
MutationContext
ParseNodeLeadingComments
(SyntaxNode node, MutationContext context)

--- Chunk 2 ---

private
static
MutationContext
ProcessComment
(SyntaxNode node, MutationContext context, string commentTrivia)


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;


===== New File Processed =====


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(PropertyDeclarationSyntax t) => t.ExpressionBody != null || t.Initializer != null && t.IsStatic();
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(PropertyDeclarationSyntax node) => (node.GetAccessor()?.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(PropertyDeclarationSyntax node) => SyntaxFactory.ParameterList();
protected override TypeSyntax ReturnType(PropertyDeclarationSyntax node) => node.Type;

--- Chunk 2 ---
protected override PropertyDeclarationSyntax SwitchToThisBodies(PropertyDeclarationSyntax node, BlockSyntax blockBody,
        ExpressionSyntax expressionBody)
    {
        if (expressionBody != null)
        {
            return node.WithAccessorList(null).WithExpressionBody(SyntaxFactory.ArrowExpressionClause(expressionBody)).WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        }

        return node.WithExpressionBody(null).WithAccessorList(
                SyntaxFactory.AccessorList(SyntaxFactory.List(new[]{
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, blockBody)}))).
            WithSemicolonToken(SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken));
    }


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====

--- Chunk 1 ---

internal
class
ExpressionSpecificOrchestrator
<T>
: NodeSpecificOrchestrator<T, ExpressionSyntax>
where T : ExpressionSyntax


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====

--- Chunk 1 ---

protected
override
ExpressionSyntax
OrchestrateChildrenMutation
(InvocationExpressionSyntax node, SemanticModel semanticModel,
        MutationContext context)


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
protected override (BlockSyntax block, ExpressionSyntax expression) GetBodies(LocalFunctionStatementSyntax node) => (node.Body, node.ExpressionBody?.Expression);
protected override ParameterListSyntax ParameterList(LocalFunctionStatementSyntax node) => node.ParameterList;
protected override TypeSyntax ReturnType(LocalFunctionStatementSyntax node)
    {
        var returnType = node.ReturnType;
        if (node.Modifiers.ContainsAsyncKeyword())
        {
            var genericReturn = node.ReturnType.DescendantNodesAndSelf().OfType<GenericNameSyntax>().FirstOrDefault();
            returnType = genericReturn?.TypeArgumentList.Arguments.First();
        }
        return returnType ?? RoslynHelper.VoidTypeSyntax();
    }


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====

--- Chunk 1 ---

{
private readonly Func<T, bool> _predicate;
/// <summary>
/// Builds a MemberAccessExpressionOrchestrator instance
/// </summary>
/// <param name="predicate">optional predicate to control which nodes can be orchestrated</param>
public MemberAccessExpressionOrchestrator(Func<T, bool> predicate = null) => _predicate = predicate;
protected override bool CanHandle(T t) => _predicate == null || _predicate(t);
protected override ExpressionSyntax InjectMutations(T sourceNode, ExpressionSyntax targetNode, SemanticModel semanticModel, MutationContext context) => context.InjectMutations(targetNode, sourceNode);
protected override MutationContext PrepareContext(T node, MutationContext context) =>
        // we are at expression level, except if we are explicitly already in a member access chain
        base.PrepareContext(node, context.Enter(context.CurrentControl != MutationControl.MemberAccess ? MutationControl.Expression : MutationControl.MemberAccess));


===== New File Processed =====


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Stryker.Core.Mutants;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// Generic class to deal with syntax nodes which mutations must be injected at statement level
/// </summary>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 2 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 3 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 4 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 5 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 6 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// This purpose of each implementation of this class is to support one specific C# code construct during the mutation process.
/// Indeed, some constructs need to be handled specifically to ensure successful mutations.
/// Others are used to inject the need mutation control logic. It is strongly suggested to review each of those classes to
/// get a grasp of how they work before adding a new one.
/// </summary>
/// <typeparam name="TNode">Roslyn type which represents the C# construct</typeparam>
/// <typeparam name="TBase">Type of the node once mutated. In practice, either <see cref="TNode"/> or a base class of it.</typeparam>
/// <remarks>Those classes are an implementation of the 'Strategy' pattern. They must remain stateless, as the same instance is used for all syntax node of

--- Chunk 2 ---

{
/// <summary>
/// Get the Roslyn type handled by this class
/// </summary>
public Type ManagedType => typeof(TNode);
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Default implementation always returns true. You can override this method to have several classes supporting various sub cases for a single node type.</remarks>
protected virtual bool CanHandle(TNode t) => t != null;
/// <summary>
/// Checks if this class will manage a specific node.
/// </summary>
/// <param name="t">Syntax node to be tested</param>
/// <returns>True if this class can process the provided node.</returns>
/// <remarks>Delegate the implementation to an polymorphic implementation.</remarks>
public bool CanHandle(SyntaxNode t) => CanHandle(t as TNode);
/// <summary>
/// Inject mutation(s) in this node.
/// </summary>

--- Chunk 3 ---
/// <param name="sourceNode">Original, unmodified syntax node</param>
/// <param name="targetNode">Variant of <paramref name="sourceNode"/> including mutated children.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context which contains pending mutations.</param>
/// <returns>A syntax node (typeof <see cref="TBase"></see>) with mutations injected, if possible./></returns>
/// <remarks>Override this method when you need to inject some code (e.g : mutation control, or analysis markers).</remarks>
protected virtual TBase InjectMutations(TNode sourceNode, TBase targetNode, SemanticModel semanticModel, MutationContext context) => targetNode;
/// <summary>
/// Generates and returns the list of possible mutations for the provided node.
/// </summary>
/// <param name="node">Node to generate mutations from.</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context.</param>

--- Chunk 4 ---
/// <returns>A list of <see cref="Mutant"/>s for the given node.</returns>
/// <remarks>You should not override this, unless you want to block mutation generation for the node. Then returns and empty list.</remarks>
protected virtual IEnumerable<Mutant> GenerateMutationForNode(TNode node, SemanticModel semanticModel, MutationContext context) =>
        context.GenerateMutantsForNode(node, semanticModel);
/// <summary>
/// Stores provided mutations.
/// </summary>
/// <param name="node">Associated node.</param>
/// <param name="mutations">Mutations to store</param>
/// <param name="context">Mutation context.</param>
/// <returns>A <see cref="MutationContext"/>instance storing existing mutations as well as the one provided</returns>
/// <remarks>You need to override this method if the generated mutations cannot be injected in place (via a conditional operator) but must be controlled
/// at the statement or block level. Default implementation does nothing.</remarks>

--- Chunk 5 ---
protected virtual MutationContext StoreMutations(TNode node, IEnumerable<Mutant> mutations, MutationContext context) =>
        context.AddMutations(mutations);
/// <summary>
/// Mutate children, grandchildren (recursively).
/// </summary>
/// <param name="node">Node which children will be mutating</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation status</param>
/// <returns>A <see cref="TBase"/> instance with the mutated children.</returns>
/// <remarks>Override this method if you want to control how the node's children are mutated. Simply return <see cref="node"/> if you want to
/// skip mutating the children node.</remarks>
protected virtual TBase OrchestrateChildrenMutation(TNode node, SemanticModel semanticModel, MutationContext context) =>
        node.ReplaceNodes(node.ChildNodes(),
            computeReplacementNode: (original, _) => context.Mutate(original, semanticModel));
/// <summary>

--- Chunk 6 ---
/// Set up the mutation context before triggering mutation.
/// </summary>
/// <param name="node">Node of interest</param>
/// <param name="context">context to be updated</param>
/// <returns>a context capturing changes, if any</returns>
/// <remarks>base implementation parse stryker comments.</remarks>
protected virtual MutationContext PrepareContext(TNode node, MutationContext context) => CommentParser.ParseNodeLeadingComments(node, context);
/// <summary>
/// Restore the mutation context after mutation have been performed
/// </summary>
/// <param name="context">Context to be updated</param>
/// <remarks>base implementation does nothing</remarks>
protected virtual void RestoreContext(MutationContext context) { }
/// <summary>
/// Mutates a node and its children. Update the mutation context with mutations needed to be injected in a higher level node.
/// The workflow is:
/// 1) adjust the context
/// 2) generate mutations for the node
/// 3) store generated mutations in the context

--- Chunk 7 ---
/// 4) recursively mutate children
/// 5) (try to) inject mutations in this node
/// 6) restore the context
/// 7) return the mutated node (with mutated children)
/// </summary>
/// <param name="node">Node to be mutated</param>
/// <param name="semanticModel"></param>
/// <param name="context">Mutation context</param>
/// <returns>A <see cref="SyntaxNode"/> instance will all injected mutations.</returns>


===== New File Processed =====

--- Chunk 1 ---

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
namespace Stryker.Core.Mutants.CsharpNodeOrchestrators;
/// <summary>
/// General handler for Statements. Remember to inherit from this class when you wand to create a statement specific logic.
/// </summary>
/// <typeparam name="T">Statement syntax type. Must inherit from <see cref="StatementSyntax"/></typeparam>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(ConstructorDeclarationSyntax t) => t.IsStatic();
protected override MutationContext PrepareContext(ConstructorDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();
/// <inheritdoc/>
/// <remarks>Injects a static marker used for coverage information; this implies converting
/// expression arrow bodied method to regular ones.</remarks>


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

--- Chunk 1 ---

{
protected override bool CanHandle(FieldDeclarationSyntax t) => t.IsStatic() && t.Declaration.Variables.Any(v => v.Initializer != null);
protected override MutationContext PrepareContext(FieldDeclarationSyntax node, MutationContext context) => base.PrepareContext(node, context).EnterStatic();


===== New File Processed =====

